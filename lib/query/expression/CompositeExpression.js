// Generated by CoffeeScript 1.6.3
/*
 * Composite expression is responsible to build a group of similar expression.
 *
 * @link   www.doctrine-project.org
 * @since  2.1
 * @author Guilherme Blanco <guilhermeblanco@hotmail.com>
 * @author Benjamin Eberlei <kontakt@beberlei.de>
*/

var CompositeExpression;

CompositeExpression = (function() {
  var get, self,
    _this = this;

  self = CompositeExpression;

  get = function(o) {
    var k, v, _results;
    _results = [];
    for (k in o) {
      v = o[k];
      _results.push(Object.defineProperty(CompositeExpression.prototype, k, {
        get: v
      }));
    }
    return _results;
  };

  /*
   * Constant that represents an AND composite expression.
  */


  self.TYPE_AND = 'AND';

  /*
   * Constant that represents an OR composite expression.
  */


  self.TYPE_OR = 'OR';

  /**
   * @property string The instance type of composite expression.
   * @property array Each expression part of the composite expression.
  */


  /**
   * Constructor.
   *
   * @param {String} type  Instance type of composite expression.
   * @param {Array}  parts Composition of expressions to be joined on composite expression.
  */


  function CompositeExpression(type, parts) {
    if (parts == null) {
      parts = [];
    }
    this.type = type;
    this.parts = [];
    this.addMultiple(parts);
  }

  /**
   * Adds multiple parts to composite expression.
   *
   * @param array parts
   *
   * @return {CompositeExpression}
  */


  CompositeExpression.prototype.addMultiple = function(parts) {
    var part, _i, _len;
    if (parts == null) {
      parts = [];
    }
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      this.add(part);
    }
    return this;
  };

  /*
   * Adds an expression to composite expression.
   *
   * @param mixed part
   *
   * @return \Doctrine\DBAL\Query\Expression\CompositeExpression
  */


  CompositeExpression.prototype.add = function(part) {
    if (part.length > 0 || (part instanceof self && part.length > 0)) {
      this.parts.push(part);
    }
    return this;
  };

  /*
   * Retrieves the amount of expressions on composite expression.
   *
   * @return integer
  */


  get({
    length: function() {
      return this.parts.length;
    }
  });

  /*
   * Retrieves the string representation of this composite expression.
   *
   * @return {String}
  */


  CompositeExpression.prototype.toString = function() {
    if (this.parts.length === 1) {
      return this.parts[0];
    }
    return '(' + this.parts.join(") " + this.type + " (") + ')';
  };

  /*
   * Returns the type of this composite expression (AND/OR).
   *
   * @return {String}
  */


  CompositeExpression.prototype.gettype = function() {
    return this.type;
  };

  return CompositeExpression;

}).call(this);

module.exports = CompositeExpression;

/*
//@ sourceMappingURL=CompositeExpression.map
*/
