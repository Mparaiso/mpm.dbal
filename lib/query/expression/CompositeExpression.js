// Generated by CoffeeScript 1.6.3
/*
Composite expression is responsible to build a group of similar expression.
*/

var CompositeExpression;

CompositeExpression = (function() {
  var get, self,
    _this = this;

  self = CompositeExpression;

  get = function(o) {
    var k, v, _results;
    _results = [];
    for (k in o) {
      v = o[k];
      _results.push(Object.defineProperty(CompositeExpression.prototype, k, {
        get: v
      }));
    }
    return _results;
  };

  /*
  Constant that represents an AND composite expression.
  */


  CompositeExpression.TYPE_AND = 'AND';

  /*
  Constant that represents an OR composite expression.
  */


  CompositeExpression.TYPE_OR = 'OR';

  /**
  @property {String} type The instance type of composite expression.
  @property {Array} parts Each expression part of the composite expression.
  */


  /**
  Constructor.
  
  @param {String} type  Instance type of composite expression.
  @param {Array}  parts Composition of expressions to be joined on composite expression.
  */


  function CompositeExpression(type, parts) {
    if (parts == null) {
      parts = [];
    }
    this.type = type;
    this.parts = [];
    this.addMultiple(parts);
  }

  /**
  Adds multiple parts to composite expression.
  
  @param {Array} parts
  @return {CompositeExpression}
  */


  CompositeExpression.prototype.addMultiple = function(parts) {
    var part, _i, _len;
    if (parts == null) {
      parts = [];
    }
    for (_i = 0, _len = parts.length; _i < _len; _i++) {
      part = parts[_i];
      this.add(part);
    }
    return this;
  };

  /*
  Adds an expression to composite expression.
  
  @param {Array} part
  @return {CompositeExpression}
  */


  CompositeExpression.prototype.add = function(part) {
    if (part.length > 0 || (part instanceof self && part.length > 0)) {
      this.parts.push(part);
    }
    return this;
  };

  /*
  @property {Number} Retrieves the amount of expressions on composite expression.
  */


  get({
    length: function() {
      return this.parts.length;
    }
  });

  /*
  Retrieves the string representation of this composite expression.
  
  @return {String}
  */


  CompositeExpression.prototype.toString = function() {
    if (this.parts.length === 1) {
      return this.parts[0];
    } else {
      return '(' + this.parts.join(") " + this.type + " (") + ')';
    }
  };

  CompositeExpression.prototype.valueOf = function() {
    return this.toString();
  };

  /*
  Returns the type of this composite expression (AND/OR).
  
  @return {String}
  */


  CompositeExpression.prototype.gettype = function() {
    return this.type;
  };

  return CompositeExpression;

}).call(this);

module.exports = CompositeExpression;

/*
//@ sourceMappingURL=CompositeExpression.map
*/
