// Generated by CoffeeScript 1.6.3
"use strict";
var CompositeExpression, Connection, ExpressionBuilder, QueryBuilder, _;

CompositeExpression = require('./expression/CompositeExpression');

ExpressionBuilder = require('./expression/ExpressionBuilder');

Connection = require('../Connection');

_ = require('underscore');

/*
QueryBuilder class is responsible to dynamically create SQL queries.

Important: Verify that every feature you use will work with your database vendor.
SQL Query Builder does not attempt to validate the generated SQL at all.

The query builder does no validation whatsoever if certain features even work with the
underlying database vendor. Limit queries and joins are NOT applied to UPDATE and DELETE statements
even if some vendors such as MySQL support it.
@class
*/


QueryBuilder = (function() {
  var self;

  self = QueryBuilder;

  /*
  The query types.
  */


  QueryBuilder.SELECT = 0;

  QueryBuilder.DELETE = 1;

  QueryBuilder.UPDATE = 2;

  QueryBuilder.INSERT = 3;

  /*
  The builder states.
  */


  QueryBuilder.STATE_DIRTY = 0;

  QueryBuilder.STATE_CLEAN = 1;

  /*
  @property {dbal.Connection} connection The DBAL Connection.
  @property {Array} sqlParts The array of SQL parts collected.
  @property {String} [sql] The complete SQL string for this query
  @property {Array} The query parameters.
  @property {Array} paramTypes The parameter type map of this query.
  @property {Number} type The type of query this is. Can be select, update or delete.
  @property {Number} state The state of the query object. Can be dirty or clean.
  @property {Number} firstResult The index of the first result to retrieve.
  @property {Number} maxResults The maximum number of results to retrieve.
  @property {Number} boundCounter The counter of bound parameters used with @see bindValue).
  */


  /*
  Initializes a new <tt>QueryBuilder</tt>.
  @param {dbal.Connection} connection The DBAL Connection.
  */


  function QueryBuilder(connection) {
    this.connection = connection;
    this.boundCounter = 0;
    this.maxResults = null;
    this.firstResult = null;
    this.state = self.STATE_CLEAN;
    this.sqlParts = {
      'select': {},
      'from': [],
      'join': {},
      'set': {},
      'where': [],
      'groupBy': null,
      'having': null,
      'orderBy': null,
      'values': {}
    };
    this.type = self.SELECT;
    this.paramTypes = {};
    this.params = {};
    this.sql = null;
  }

  /*
  Gets an ExpressionBuilder used for object-oriented construction of query expressions.
  This producer method is intended for convenient inline usage. Example:
    <code>
   qb = conn.createQueryBuilder()
       .select('u')
       .from('users', 'u')
       .where(qb.expr().eq('u.id', 1)) 
  </code>
  For more complex expression construction, consider storing the expression
  builder object in a local variable.
  @return {ExpressionBuilder}
  */


  QueryBuilder.prototype.expr = function() {
    return new ExpressionBuilder({});
  };

  /*
   Gets the type of the currently built query.
        @return integer
  */


  QueryBuilder.prototype.gettype = function() {
    return this.type;
  };

  /*
   Gets the associated DBAL Connection for this query builder.
  @return dbal.Connection
  */


  QueryBuilder.prototype.getconnection = function() {
    return this.connection;
  };

  /*
  Gets the state of this query builder instance.
  @return {Number} Either QueryBuilder.STATE_DIRTY or QueryBuilder.STATE_CLEAN.
  */


  QueryBuilder.prototype.getstate = function() {
    return this.state;
  };

  /*
  Gets the complete SQL string formed by the current specifications of this QueryBuilder.
  <code>
       qb = em.createQueryBuilder()
           .select('u')
           .from('User', 'u')
       echo qb.getSQL()  // SELECT u FROM User u
   </code>
  @return string The SQL query string.
  */


  QueryBuilder.prototype.getSQL = function() {
    var sql;
    if (this.sql && this.state === self.STATE_CLEAN) {
      return this.sql;
    }
    switch (this.type) {
      case self.INSERT:
        sql = this.getSQLForInsert();
        break;
      case self.DELETE:
        sql = this.getSQLForDelete();
        break;
      case self.UPDATE:
        sql = this.getSQLForUpdate();
        break;
      default:
        sql = this.getSQLForSelect();
    }
    this.state = self.STATE_CLEAN;
    this.sql = sql;
    return sql;
  };

  /*
  Sets a query parameter for the query being constructed.
  <code>
       qb = conn.createQueryBuilder()
           .select('u')
           .from('users', 'u')
           .where('u.id = :user_id')
           .setParameter(':user_id', 1) 
   </code>
  @param {String|Number} key   The parameter position or name.
  @param {Any}          value The parameter value.
  @param {String|Null}    type  One of the PDO.PARAM_* constants.
  @return QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.setparameter = function(key, Value, type) {
    if (type == null) {
      type = null;
    }
    if (type !== null) {
      this.paramTypes[key] = type;
    }
    this.params[key] = value;
    return this;
  };

  /*
  Sets a collection of query parameters for the query being constructed.
  <code>
       qb = conn.createQueryBuilder()
           .select('u')
           .from('users', 'u')
           .where('u.id = :user_id1 OR u.id = :user_id2')
           .setParameters({
               ':user_id1' : 1,
               ':user_id2' : 2
          }) 
  </code>
  @param {Object} params The query parameters to set.
  @param {Object} types  The query parameters types to set.
  @return QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.setparameters = function(params, types) {
    if (types == null) {
      types = {};
    }
    this.paramTypes = types;
    this.params = params;
    return this;
  };

  /*
  Gets all defined query parameters for the query being constructed.
  @return {Object} The currently defined query parameters.
  */


  QueryBuilder.prototype.getparameters = function() {
    return this.params;
  };

  /*
  Gets a (previously set) query parameter of the query being constructed.
  @param mixed key The key (index or name) of the bound parameter.
  @return mixed The value of the bound parameter.
  */


  QueryBuilder.prototype.getparameter = function(key) {
    return this.params[key];
  };

  /*
  Sets the position of the first result to retrieve (the "offset").
  @param {Number} firstResult The first result to return.
  @return QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.setfirstresult = function(firstResult) {
    this.state = self.STATE_DIRTY;
    this.firstResult = firstResult;
    return this;
  };

  /*
  Gets the position of the first result the query object was set to retrieve (the "offset").
  Returns NULL if @link setFirstResult was not applied to this QueryBuilder.
  @return integer The position of the first result.
  */


  QueryBuilder.prototype.getfirstresult = function() {
    return this.firstResult;
  };

  /*
  Sets the maximum number of results to retrieve (the "limit").
  @param integer maxResults The maximum number of results to retrieve.
  @return \Doctrine\DBAL\Query\QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.setmaxResults = function(maxResuLts) {
    this.state = self.STATE_DIRTY;
    this.maxResults = maxResults;
    return this;
  };

  /*
  Gets the maximum number of results the query object was set to retrieve (the "limit").
  Returns NULL if @link setMaxResults was not applied to this query builder.
  @return integer The maximum number of results.
  */


  QueryBuilder.prototype.getmaxResults = function() {
    return this.maxResults;
  };

  /*
  Either appends to or replaces a single, generic query part.
  The available parts are: 'select', 'from', 'set', 'where',
  'groupBy', 'having' and 'orderBy'.
  @param string  sqlPartName
  @param string  sqlPart
  @param boolean append
  @return \Doctrine\DBAL\Query\QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.add = function(sqlPartName, sqlPart, append) {
    var isArray, isMultiple, key, part, _i, _len;
    if (append == null) {
      append = false;
    }
    isArray = sqlPart instanceof Array;
    isMultiple = this.sqlParts[sqlPartName] instanceof Array;
    debugger;
    this.state = self.STATE_DIRTY;
    if (append) {
      if (sqlPartName === "orderBy" || sqlPartName === "groupBy" || sqlPartName === "select" || sqlPartName === "set") {
        for (_i = 0, _len = sqlPart.length; _i < _len; _i++) {
          part = sqlPart[_i];
          this.sqlParts[sqlPartName].push(part);
        }
      } else if (isArray && _.isArray(key = Object.keys(sqlPart)[0])) {
        this.sqlParts[sqlPartName][key].push(sqlPart[key]);
      } else if (isMultiple) {
        this.sqlParts[sqlPartName].push(sqlPart);
      } else {
        this.sqlParts[sqlPartName].push(sqlPart);
      }
    } else {
      this.sqlParts[sqlPartName] = sqlPart;
    }
    return this;
  };

  /*
  Specifies an item that is to be returned in the query result.
  Replaces any previously specified selections, if any.
  <code>
  qb = conn.createQueryBuilder()
      .select('u.id', 'p.id')
      .from('users', 'u')
      .leftJoin('u', 'phonenumbers', 'p', 'u.id = p.user_id') 
  </code>
  @param mixed select The selection expressions.
  @return {QueryBuilder} This QueryBuilder instance.
  */


  QueryBuilder.prototype.select = function(select) {
    var selects;
    this.type = self.SELECT;
    if (!select) {
      return this;
    }
    selects = select instanceof Array ? select : [].slice.apply(arguments);
    return this.add('select', selects, false);
  };

  /*
  Turns the query being built into an insert query that inserts into
  a certain table
      <code>
       qb = conn.createQueryBuilder()
           .insert('users')
           .values(
               array(
                   'name' : '?',
                   'password' : '?'
               )
           ) 
      </code>
  @param {string} insert The table into which the rows should be inserted.
  @return {QueryBuilder} This QueryBuilder instance.
  */


  QueryBuilder.prototype.insert = function(insert) {
    if (insert == null) {
      insert = null;
    }
    this.type = self.INSERT;
    if (!insert) {
      return this;
    }
    return this.add('from', {
      'table': insert
    });
  };

  /*
   Creates and adds a query root corresponding to the table identified by the
   given alias, forming a cartesian product with any existing query roots.
        <code>
       qb = conn.createQueryBuilder()
           .select('u.id')
           .from('users', 'u')
   </code>
  @param {string} from   The table.
  @param {string} alias  The alias of the table.
  @return {QueryBuilder} This QueryBuilder instance.
  */


  QueryBuilder.prototype.from = function(from, alias) {
    return this.add('from', {
      'table': from,
      'alias': alias
    }, true);
  };

  /*
      Specifies one or more restrictions to the query result.
      Replaces any previously specified restrictions, if any.
      <code>
           qb = conn.createQueryBuilder()
               .select('u.name')
               .from('users', 'u')
               .where('u.id = ?') 
          // You can optionally programatically build and/or expressions
           qb = conn.createQueryBuilder() 
                or = qb.expr().orx() 
           or.add(qb.expr().eq('u.id', 1)) 
           or.add(qb.expr().eq('u.id', 2)) 
                qb.update('users', 'u')
               .set('u.password', md5('password'))
               .where(or) 
      </code>
      @param {Any} predicates The restriction predicates.
      @return {QueryBuilder} This QueryBuilder instance.
  */


  QueryBuilder.prototype.where = function(predicates) {
    if (arguments.length !== 1 && predicates instanceof CompositeExpression) {
      predicates = new CompositeExpression(CompositeExpression.TYPE_AND, arguments);
    }
    return this.add('where', [predicates]);
  };

  /*
      Adds one or more restrictions to the query results, forming a logical
      conjunction with any previously specified restrictions.
            <code>
           qb = conn.createQueryBuilder()
               .select('u')
               .from('users', 'u')
               .where('u.username LIKE ?')
               .andWhere('u.is_active = 1') 
       </code>
      @param {Any} where The query restrictions.
      @return {QueryBuilder} This QueryBuilder instance.
      @see where()
  */


  QueryBuilder.prototype.andWhere = function(where) {
    var args;
    args = [].slice.call(arguments);
    where = this.getQueryPart('where');
    if (where instanceof CompositeExpression && where.getType() === CompositeExpression.TYPE_AND) {
      where.addMultiple(args);
    } else {
      args.unshift(where);
      where = new CompositeExpression(CompositeExpression.TYPE_AND, args);
    }
    return this.add('where', [where]);
  };

  /*
      Adds one or more restrictions to the query results, forming a logical
      disjunction with any previously specified restrictions.
      <code>
       qb = em.createQueryBuilder()
           .select('u.name')
           .from('users', 'u')
           .where('u.id = 1')
           .orWhere('u.id = 2') 
      </code>
      @param {Any} where The WHERE statement.
      @return {QueryBuilder} This QueryBuilder instance.
      @see where()
  */


  QueryBuilder.prototype.orWhere = function(where) {
    var args;
    args = [].slice.call(arguments);
    where = this.getQueryPart('where');
    if (where instanceof CompositeExpression && where.getType() === CompositeExpression.TYPE_OR) {
      where.addMultiple(args);
    } else {
      args.unshift(where);
      where = new CompositeExpression(CompositeExpression.TYPE_OR, args);
    }
    return this.add('where', [where]);
  };

  /*
  Sets a value for a column in an insert query.
  <code>
       qb = conn.createQueryBuilder()
           .insert('users')
           .values(
               array(
                   'name' : '?'
               )
           )
           .setValue('password', '?') 
  </code>
  @param string column The column into which the value should be inserted.
  @param string value  The value that should be inserted into the column.
  @return QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.setvalue = function(column, value) {
    this.sqlParts['values'][column] = value;
    return this;
  };

  /*
  Specifies values for an insert query indexed by column names.
  Replaces any previous values, if any.
        <code>
       qb = conn.createQueryBuilder()
           .insert('users')
           .values(
               array(
                   'name' : '?',
                   'password' : '?'
               )
           ) 
   </code>
  @param array values The values to specify for the insert query indexed by column names.
  @return QueryBuilder This QueryBuilder instance.
  */


  QueryBuilder.prototype.values = function(values) {
    return this.add('values', values);
  };

  /*
      Gets a query part by its name.
      @param {String} queryPartName
      @return mixed
  */


  QueryBuilder.prototype.getQueryPart = function(queryPartName) {
    return this.sqlParts[queryPartName];
  };

  /*
      @return {String}
      @throws {QueryException}
  */


  QueryBuilder.prototype.getSQLForSelect = function() {
    var from, fromAlias, fromClause, fromClauses, joins, knownAliases, query, _i, _len, _ref, _ref1;
    query = "SELECT " + (this.sqlParts.select.join(', ')) + " FROM ";
    fromClauses = {};
    knownAliases = {};
    /* Loop through all FROM clauses*/

    _ref = this.sqlParts.from;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      from = _ref[_i];
      knownAliases[from['alias']] = true;
      fromClause = "" + from['table'] + " " + from['alias'] + (this.getSQLForJoins(from['alias'], knownAliases));
      fromClauses[from['alias']] = fromClause;
    }
    _ref1 = this.sqlParts.join;
    for (fromAlias in _ref1) {
      joins = _ref1[fromAlias];
      if (!knownAliases[fromAlias]) {
        throw "unknowAlias " + fromAlias + " " + (_.keys(knownAliases));
      }
    }
    return query.concat(Object.keys(fromClauses).map(function(k) {
      return fromClauses[k];
    }).join(', ')).concat(this.sqlParts['where'].length > 0 ? ' WHERE ' + this.sqlParts['where'].join(' ') : '').concat(this.sqlParts['groupBy'] ? ' GROUP BY ' + this.sqlParts['groupBy'].join(', ') : '').concat(this.sqlParts['having'] ? ' HAVING ' + this.sqlParts['having'] : '').concat(this.sqlParts['orderBy'] ? ' ORDER BY ' + this.sqlParts['orderBy'].join(', ') : '');
  };

  /*
  Converts this instance into an INSERT string in SQL.
  @return string
  */


  QueryBuilder.prototype.getSQLForInsert = function() {
    return "INSERT INTO " + this.sqlParts.from.table + " (" + (_.keys(this.sqlParts.values).join(', ')) + " VALUES(" + (_.values(this.sqlParts.values).join(', ')) + ")";
  };

  /*
  @param {string} fromAlias
  @param {array}  knownAliases
  @return {string}
  */


  QueryBuilder.prototype.getSQLForJoins = function(fromAlias, knownAliases) {
    var join, sql, _ref;
    sql = '';
    if ((_ref = this.sqlParts.join) != null ? _ref.fromAlias : void 0) {
      for (join in this.sqlParts.join.fromAlias) {
        sql += " " + (join.joinType.toUpperCase()) + " JOIN " + join['joinTable'] + " {join['joinAlias']} ON " + join['joinCondition'] + " ";
        knownAliases[join.joinAlias] = true;
        sql += this.getSQLForJoins(join.joinAlias, knownAliases);
      }
    }
    return sql;
  };

  /*
      Deep clone of all expression objects in the SQL parts.
      @return void
  */


  QueryBuilder.prototype.clone = function() {
    throw "not implemented yet";
  };

  QueryBuilder.prototype.toString = function() {
    return this.getSQL();
  };

  /*
      @return {String}
  */


  QueryBuilder.prototype.valueOf = function() {
    return this.toString();
  };

  return QueryBuilder;

})();

module.exports = QueryBuilder;

/*
//@ sourceMappingURL=QueryBuilder.map
*/
